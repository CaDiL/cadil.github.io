[{"content":"GKE дээр Helm, Күбернетес ашиглан жишээ апплкейшн суулгаж тохируулах  Google Kubernetes Engine дээр кластер үүсгэх Helm, Tiller суулгах TLS Key үүсгэх Odoo-г суулгах  Google Kubernetes Engine дээр кластер үүсгэх Google Cloud Platform дээр Google Kubernetes Engine дээр кластер үүсгэх Helm Chart суулгаж TLS, Cert-Manager суулган тохируулж сүүлд нь Odoo-г суулгаж үзнэ.\n gcloud суулгах kubectl суулгах  gcloud дамжуулан GCP - тэй холбогдоно. Google Cloud Platform - бүртгэл байхгүй бол эхлээд бүртгүүлээрэй.\nkubectl gcloud суулгасан бол дээр байгаа гарын авлага ашиглахгүй kubectl суулгая гэвэл:\ngcloud components install kubectl Кластер үүсгэхээсээ ѳмнѳ нэвтрэн орно:\ngcloud auth application-default login Нэвтрэн орсон бол доорк коммандараар шинэ прожект үүсгэнэ:\ngcloud projects create ${PROJECT} Эсхүл заавал CLI-ээр үүсгэхгүй гэвэл GCP дээрээс browser дээрээс орон шинэ прожект үүсгэж болно. Терминал дээрээ ѳѳрийн тѳслийг default болгож zone тохиргоо хийх бол:\ngcloud config set project ${PROJECT} gcloud config set compute/zone ${ZONE}  Zone жигсаалт авах бол: gcloud compute zones list\n Одоо шинээр үүсгэсэн тѳсѳл дотроо кластер үүсгэе. Google Kubernetes Engine -г идэвхжүүлээгүй бол эхлээд brwoser-ѳѳсѳѳ GCP -г ороод GKE-г enable хийх хийнэ. Kubernetes Engine -г ороод browser дээрээс анх удаа кластер үүсгэж байгаа хичээл болон жишиг кластер тохироог санал болгоно. Тэр аргаар нь үүсгэж болно. Эсхүл доор байгаа командаар үүсгэж болно.\ngcloud beta container --project ${PROJECT} clusters create \u0026#34;my-first-cluster-1\u0026#34; \\  --zone \u0026#34;us-central1-c\u0026#34; \\  --no-enable-basic-auth \\  --cluster-version \u0026#34;1.16.15-gke.4901\u0026#34; \\  --machine-type \u0026#34;e2-medium\u0026#34; \\  --image-type \u0026#34;COS\u0026#34; \\  --disk-type \u0026#34;pd-standard\u0026#34; \\  --disk-size \u0026#34;100\u0026#34; \\  --scopes \u0026#34;https://www.googleapis.com/auth/devstorage.read_only\u0026#34;,\u0026#34;https://www.googleapis.com/auth/logging.write\u0026#34;,\u0026#34;https://www.googleapis.com/auth/monitoring\u0026#34;,\u0026#34;https://www.googleapis.com/auth/servicecontrol\u0026#34;,\u0026#34;https://www.googleapis.com/auth/service.management.readonly\u0026#34;,\u0026#34;https://www.googleapis.com/auth/trace.append\u0026#34; \\  --no-enable-cloud-logging \\  --no-enable-cloud-monitoring \\  --no-enable-ip-alias \\  --network \u0026#34;projects/${PROJECT}/global/networks/default\u0026#34; \\  --subnetwork \u0026#34;projects/${PROJECT}/regions/us-central1/subnetworks/default\u0026#34; \\  --addons HorizontalPodAutoscaling \\  --enable-autoupgrade \\  --enable-autorepair \\  --enable-autoscaling \\  --num-nodes \u0026#34;2\u0026#34; \\  --min-nodes \u0026#34;2\u0026#34; \\  --max-nodes \u0026#34;5\u0026#34; zones: Кластер үүсгэж байгаа сервверийн байршил. machine-type: Кластерын үүсгэж байгаа тѳхѳѳрѳмжийн сонголт. Ямар тѳрлийн тѳхѳѳрѳмж сонгхож байгаагаас үнэ болон хэдэн node үүсгэх лимит зэрэгг тодорохйлогдоно. Дэлгэрэнгүй судлах бол: Machine Types. addons: Автоматаар буюу ачаалал их болох үед node ѳргѳтгѳл хийх тохиргоо оруулав: HorizontalPodAutoscaling. min-node: Автомат ѳргѳтгѳл хийж байх үед кластерт хамгийн бага байх node. max-node: Автомат ѳргѳтгѳл хийж байх үед кластерт хамгийн их байх node.\nШинээр үүсгэсэн кластерт role binding тохируулна:\ngcloud container clusters get-credentials ${Кластер нэр} kubectl create clusterrolebinding cluster-admin-binding \\  --clusterrole cluster-admin \\  --user $(gcloud config get-value account) Helm суулгах Helm суулгах:\ncurl https://raw.githubusercontent.com/helm/helm/master/scripts/get | bash kubectl create serviceaccount -n kube-system tiller kubectl create clusterrolebinding tiller-cluster-rule \\  --clusterrole=cluster-admin --serviceaccount=kube-system:tiller to be continued\u0026hellip;\n","permalink":"https://cadil.github.io/posts/2021-01-14-gke-kubernetes/","summary":"GKE дээр Helm, Күбернетес ашиглан жишээ апплкейшн суулгаж тохируулах  Google Kubernetes Engine дээр кластер үүсгэх Helm, Tiller суулгах TLS Key үүсгэх Odoo-г суулгах  Google Kubernetes Engine дээр кластер үүсгэх Google Cloud Platform дээр Google Kubernetes Engine дээр кластер үүсгэх Helm Chart суулгаж TLS, Cert-Manager суулган тохируулж сүүлд нь Odoo-г суулгаж үзнэ.\n gcloud суулгах kubectl суулгах  gcloud дамжуулан GCP - тэй холбогдоно. Google Cloud Platform - бүртгэл байхгүй бол эхлээд бүртгүүлээрэй.","title":"GKE дээр Odoo-г суулгах"},{"content":"Kubernetes Helm-г ашиглан bitnami тохируулсан апплкэйшнг Күбернетесд суулган үзье. Ингэснээр Күбернетес ажиллагааг энгийн хялбар аргаар харж туршиж болно.\nminikube start-г терминал дээр бичин күбернетэс кластераа ажилууллсан бол:\n# Bitnami Helm Chart рэпо-г эхлээд нэмнэ. $ helm repo add bitnami https://charts.bitnami.com/bitnami # Default namespace-т my-release - нэрэээр Odoo-г суулгана. $ helm install my-release bitnami/odoo Дээрх коммандууыг ажиллуусан бол output терминал дээр харуулна.\nNAME: my-release LAST DEPLOYED: *** NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: ******************************************************************* *** PLEASE BE PATIENT: Odoo may take a few minutes to install *** ******************************************************************* 1. Get the Odoo URL by running: ** Please ensure an external IP is associated to the my-release-odoo service before proceeding ** ** Watch the status using: kubectl get svc --namespace default -w my-release-odoo ** export SERVICE_IP=$(kubectl get svc --namespace default my-release-odoo --template \u0026#34;{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\u0026#34;) echo \u0026#34;Odoo URL: http://$SERVICE_IP/\u0026#34; 2. Obtain the login credentials export ODOO_EMAIL=user@example.com export ODOO_PASSWORD=$(kubectl get secret --namespace default my-release-odoo -o jsonpath=\u0026#34;{.data.odoo-password}\u0026#34; | base64 --decode) echo Email : $ODOO_EMAIL echo Password: $ODOO_PASSWORD Output нь ойлгоход хялбар энгийн зааварчилгаа байгаа, терминал дээр зааврын дагуу хуулж ажилууллна.\nkubectl get svc --namespace default -w my-release-odoo Сервисын статусыг дээрх коммандаар харах боломжтой гэж output дээр тайлбарлсан байгаа. Гэхдээ локал орчинд minikube ашиглаж байгаа үед Load Balancer-н экстернал ip -г авч болохгүй шалтгаан нь Cloud Provider-ууд дээр байдаг шиг Minikube -д ѳѳрт нь Load Balancer layer - байхгүй.\nТиймээс minikube-д экстернал ip-г түр зүүр нээх хэрэгтэй болно. Доор байгаа коммандыг шинэ терминал нээгээд ажилууллна.\nminikube tunnel Ажилуулах үед нууц үг асууна. Нууц үг хийснээр локал орчинд Load Balancer шинээр үүсгэнэ.\nЭсхүл service.type -г LoadBalancer биш NodePort болгоод ажилуулах бас нэг арга бий. Жишээ нь:\nhelm install odoo bitnami/odoo --set serviceType=NodePort kubectl get svc --namespace default -w my-release-odoo - г коммандыг дахин ажилууллаад үзээрэй. Экстернал IP хэсгийг тодорхойлсон байгаа. Одоо SERVICE_IP -г browser дээр хуулаад done.\nПод статус шалгах kubectl get pods release устгаж цэвэрлэх helm uninstall my-release Сервисийн параметруудыг ѳѳрчлѳх конфиг хийх бол эндээс харж болох юм байна. Ѳѳр олон тохихруулга байгаа болохоор заавартай нь танилцаад аваарай.\nСурвалжууд \u0026amp; Bookmarks:  https://github.com/helm/helm https://github.com/bitnami/charts https://github.com/bitnami/charts/tree/master/bitnami/odoo https://docs.bitnami.com/kubernetes/get-started-kubernetes/  ","permalink":"https://cadil.github.io/posts/2021-01-13-kubernetes-with-odoo/","summary":"Kubernetes Helm-г ашиглан bitnami тохируулсан апплкэйшнг Күбернетесд суулган үзье. Ингэснээр Күбернетес ажиллагааг энгийн хялбар аргаар харж туршиж болно.\nminikube start-г терминал дээр бичин күбернетэс кластераа ажилууллсан бол:\n# Bitnami Helm Chart рэпо-г эхлээд нэмнэ. $ helm repo add bitnami https://charts.bitnami.com/bitnami # Default namespace-т my-release - нэрэээр Odoo-г суулгана. $ helm install my-release bitnami/odoo Дээрх коммандууыг ажиллуусан бол output терминал дээр харуулна.\nNAME: my-release LAST DEPLOYED: *** NAMESPACE: default STATUS: deployed REVISION: 1 TEST SUITE: None NOTES: ******************************************************************* *** PLEASE BE PATIENT: Odoo may take a few minutes to install *** ******************************************************************* 1.","title":"Helm Chart ашиглан Odoo-г локал орчинд суулгах"},{"content":"Minikube болон kubectl суулгах Minikube ашиглан локал Kubernetes Cluster үүсгэх үзье. Эхлээд minikube суулгана.\nMinikube суулгахдаа: Lunix: Binary:\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube Debain Package:\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb sudo dpkg -i minikube_latest_amd64.deb MacOS: Homebrew ашиглан суулгана.\nbrew install minikube Бусад OS болон дэлгэрэнгүйг эндээс ороод танилцаарай.\nKubectl суулгахдаа: kubectl нь Kubernetes-н Command Line Tool ба cluster инспект хийх лог шалгах deploy хийх зэрэг бүхий л хэрэгтэй коммандууд ажилууллна. Дэлгэрэнгүй\nMinikube асаах: minikube start MacOS дээр асаж буй лог:\n😄 minikube v1.15.1 on Darwin 10.15.7 ✨ Using the hyperkit driver based on existing profile 👍 Starting control plane node minikube in cluster minikube 🔄 Restarting existing hyperkit VM for \u0026#34;minikube\u0026#34; ... ... 🏄 Done! kubectl is now configured to use \u0026#34;minikube\u0026#34; cluster and \u0026#34;default\u0026#34; namespace by default Minikube унтраах: minikube stop ","permalink":"https://cadil.github.io/posts/2021-01-12-kubernetes-install/","summary":"Minikube болон kubectl суулгах Minikube ашиглан локал Kubernetes Cluster үүсгэх үзье. Эхлээд minikube суулгана.\nMinikube суулгахдаа: Lunix: Binary:\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube Debain Package:\ncurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb sudo dpkg -i minikube_latest_amd64.deb MacOS: Homebrew ашиглан суулгана.\nbrew install minikube Бусад OS болон дэлгэрэнгүйг эндээс ороод танилцаарай.\nKubectl суулгахдаа: kubectl нь Kubernetes-н Command Line Tool ба cluster инспект хийх лог шалгах deploy хийх зэрэг бүхий л хэрэгтэй коммандууд ажилууллна. Дэлгэрэнгүй","title":"Minikube болон kubectl суулгах"},{"content":"Күбернетес Орчин Хѳгжүүлэгч нарт илүү хѳнгѳн орчин, локал дээр ажиллах, тестийн орчин гэх мэт орчнуудад зориулан гаргасан хувилбарууд байна:\n  k3s-н илүү хѳнгѳн бүтэцтэй болохоор Күбернетесд хэрэггүй гэсэн зүйлсийг хасаад зѳвхѳн чухал зүйлсийг авсан хувилбар байна. Яагаад ийм хувилбар хэрэгтэй болсон бэ гэхээр IoT, ARM суурьт CPU дээр ажиллах үед хѳнгѳн бүтэцтэй байхад хялбар ажиллагаа хурд чухал. Олон Raspberry Pi-г нэгтгээд тус тусд нь кластер болгоё гэж үзвэл k8s(Kubernetes)-с илүү k3s илүү тохиромжтой.\n  Kind нь локал орчинд Kubernetes турших, хийсвэр кластер үүсгэх, хѳгжүүлэлт, туршилт хийх үед ашиглана.\n  Minikube - Kind-тай адилхан локал орчинд Күбернетесийг кластер дээр ажилууллах. Load Balancer, VM, container, docker, external ip, internal ip, tunnel гээд бүгдийг Күбернетес орчинд зориулад single node үүсгэнэ.\n  ","permalink":"https://cadil.github.io/posts/2021-01-11-kubernetes-environment/","summary":"Күбернетес Орчин Хѳгжүүлэгч нарт илүү хѳнгѳн орчин, локал дээр ажиллах, тестийн орчин гэх мэт орчнуудад зориулан гаргасан хувилбарууд байна:\n  k3s-н илүү хѳнгѳн бүтэцтэй болохоор Күбернетесд хэрэггүй гэсэн зүйлсийг хасаад зѳвхѳн чухал зүйлсийг авсан хувилбар байна. Яагаад ийм хувилбар хэрэгтэй болсон бэ гэхээр IoT, ARM суурьт CPU дээр ажиллах үед хѳнгѳн бүтэцтэй байхад хялбар ажиллагаа хурд чухал. Олон Raspberry Pi-г нэгтгээд тус тусд нь кластер болгоё гэж үзвэл k8s(Kubernetes)-с илүү k3s илүү тохиромжтой.","title":"Күбернетес Орчин"},{"content":"Күбернетес түүхээс 2014 оны дунд үеэс Google-н Borg систем дээрээс суурь тавигдаж тухайн үедээ уг тѳсѳл дээр ажиллаж байсан хѳгжүүлэгч нар нэгдэн цааш хѳгжүүлэлт хийсэн байна. Google дэх уг тѳслийн анхдагч нэр Project 7 буюу Star Trek кинон дээрх зохиол дүрүүдийн хэсгээс нэр, логон санаа гарсан юм байна. Күбернетес цааш жѳгжүүлэлтийн явцад C++ хэлээс Go хэл рүү шилжин Kubernetes \u0026ldquo;v1\u0026rdquo; 2015 оны 7-р сард 10-нд release-ээ анх гарчээ.\nКүбернетес гэж юу вэ? Товчоор Күбернетес нь контейнеруудыг удирдан зохион байгуулж кластер(ууд) доторх апплкэйшнг өргөтгөл хийх автоматжуулалт. Продакшн орчинг дагаад Хѳгжүүлэлтийн орчин автомэйшн хийгдэнэ (Travis, Github Actions, Jenkins гэх мэт нэмэлт CI хэрэглэх байх).\n Сурвалж: Kubernetes documentation\n Master Node (aka: Control Plane) CLI, клинентаас илгээгдэж байгаа ѳгѳгдлүүд API - гаар дамжин Мастер node -д ирэн шийдвэрлэгдэнэ. Мастер Node -г ажиллагааг дэлгэрүүлбэл:\n kube-apiserver etcd kube-controller-manager kube-scheduler  Бүтцийн дагуу задлан авч үзвэл:\n kube-apiserver: Күбернетес кластер доторх хүсэлтийг зохицуулан шийдвэрлэнэ. Жишээ нь под, репликас тохируулга, ѳргѳтгѳлүүд kube-scheduler, kube-controller-manager ирсэн хүсэлтүүд Күбернетес API серверээр дамжин кластер дах шинэчлэл ѳѳрчлѳлтийг хийж гүйцэтгэнэ.   etcd: Key Value Store нь kubernetes - тэй хоршиж ажиллахдаа кластер(ууд)-т ѳгѳгдлийг хадаглах backend ажиллагааг хангана.  Доорх жишээнд мастер node дотор ectd -г под хэлбэрээр хоршин ажиллаж байна.  Сурвалж: Kubernetes documentation\n Доорх жишээнд ectd -г экстернал кластер болгон мастер node - тэй хоршин ажиллаж байна. Ингэснээр хамгаалалт болон ѳргѳтгѳл хийхэд гэх мэт илүү уян хатан тѳлѳвтэй болно.  Сурвалж: Kubernetes documentation\n Под үүсгэж буй ажиллагааг харуулсан зураг. Etcd - ажиллагааг ойлгоход хялбар зураг  Сурвалж: blog.heptio.com\n  kube-controller-manager: Системийн хэвийн ажиллаж байгаа эсэхийг давтамжтайгаар шалгах процесс. kube-scheduler: Күбернетес хуваарилагч нь аль под аль node руу хуваарилагдан очих ёстойг тодорхойлно. Хуваарилагчаас тодорхойлсон бүтцийн дагуу kubelet цааш хариуцан зѳѳвѳрлѳх үйлдийг хийнэ.  Worker Node  kubelet kube-proxy Container runtime  kubelet: Подтой холбогдон контейнер(ууд) хэвийн ажиллаж байгааг хянах, ажилууллах үйлдлийг API серверээр дамжуулан мастер node-тэй холбож ѳгдѳг. Ѳѳрѳѳр хэлбэл worker node-ыг мастер node-тэй холбох зуучлагч юм.\nkube-proxy: Сервис дээр worker node тус бүр дээр load balancer (ачаалал тэнцвэржүүлэгч) хийж IP хаяг болон сүлжээний урсгалыг зохицуулдаг.\nContainer runtime: Контейнерын lifecycle-г тодорхойлж байдаг. Күбернетэс CRI нэвтрүүлж контейнерийн runtime-уудыг дэмжин ажиллана. Үүнд Docker, containerd, CRI-O гэх мэт.\nПод: Кластер дотор нэг эсхүл олон контейнеруудаас бүрдэн ажиллаж байгаа системийн илэрхийлэл бол под юм.\n Нэг подод нэг контейнер Олон подод олон контейнерууд  Под доторх контейнер(ууд) ѳѳрийн нѳѳц, нетворкийг хуваалцан ашиглана. Ѳѳрѳѳр хэлбэл нэг эсхүл олон контейнеруудыг холбон нэг подод оруулан (контейнерууд) хоорондоо холбогдон үйлдэл хийх боломжтой тусгаарлагдсан орчин үүсгэнэ.\nСурвалжууд \u0026amp; Bookmarks  https://etcd.io/ https://github.com/k3s-io/k3s https://www.ibm.com/cloud/blog/kubernetes-ingress https://k3s.io/ https://kind.sigs.k8s.io/ https://kubernetes.io/docs/concepts/services-networking/ingress/ https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes) https://kubernetes.io/docs/tasks/tools/ https://medium.com/@tumenzul/kubernetes-%D0%BD-%D0%B0%D0%B6%D0%B8%D0%BB%D0%BB%D0%B0%D0%B3%D0%B0%D0%B0%D0%BD%D1%8B-%D0%B7%D0%B0%D1%80%D1%87%D0%BC%D1%8B%D0%B3-%D0%BE%D0%B9%D0%BB%D0%B3%D0%BE%D1%85-%D0%BD%D1%8C-abc9c0b82d35 https://medium.com/better-programming/a-closer-look-at-etcd-the-brain-of-a-kubernetes-cluster-788c8ea759a5 https://medium.com/faun/what-is-a-kubernetes-pod-67215193ed98 https://medium.com/google-cloud https://medium.com/google-cloud/understanding-kubernetes-networking-pods-7117dd28727 https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186 https://medium.com/swlh/kubernetes-architecture-explained-in-brief-6a07f59193e https://mn.wikipedia.org/wiki/Load_balancing https://bells17.medium.com/kubernetes-ccm-d4d3c71ba523 https://www.cncf.io/blog/2020/12/14/kubernetes-101-an-introduction/ https://github.com/kodekloudhub/certified-kubernetes-administrator-course  ","permalink":"https://cadil.github.io/posts/2021-01-09-kubernetes-history/","summary":"Күбернетес түүхээс 2014 оны дунд үеэс Google-н Borg систем дээрээс суурь тавигдаж тухайн үедээ уг тѳсѳл дээр ажиллаж байсан хѳгжүүлэгч нар нэгдэн цааш хѳгжүүлэлт хийсэн байна. Google дэх уг тѳслийн анхдагч нэр Project 7 буюу Star Trek кинон дээрх зохиол дүрүүдийн хэсгээс нэр, логон санаа гарсан юм байна. Күбернетес цааш жѳгжүүлэлтийн явцад C++ хэлээс Go хэл рүү шилжин Kubernetes \u0026ldquo;v1\u0026rdquo; 2015 оны 7-р сард 10-нд release-ээ анх гарчээ.\nКүбернетес гэж юу вэ?","title":"Күбернетес тухай"},{"content":"Odoo -г Docker-с ажилууллах  Odoo -н тухай Bitnami-г ашиглан Bitnami-docker-odoo - ажилууллах docker-compose - коммандын талаар Docker Volume \u0026amp; persistent volume claim талаар Docker-compouse ажилууллах  Odoo-н тухайд Нээлттэй эх дээрх бизнес апплкэйшн ERP нь вэб дээр бүрэн ажиллах, ѳѳр системтэй интеграци хийх боломж, l10n зэргийг шийдсэн цогц апплкэйшн юм.\nBitnami-н тухайд Нээлттэй эх дээр суурьтай OSS софтвейрыг хялбар аргаар хүссэн орчин дээр суулган ажилуулна. Клоуд хостинг хийж байгаа бол Helm Chart -г ашиглан күбэрнетес, клустер-г хялбархан тохируулна. Гэхдээ күбэрнетес, клустертэй ажиллаж байгаа үед гарын авлага, документ, тест зэргийг сайтар судалсны дараа турших хэрэгтэй.\nDocker Compose Compose нь нэгээс олон контейнеруудыг нэг дор ажилууллах үед YAML файл дотор тохируулсан бүтцийг ашиглан докер ажиллах процесс юм.\nДокэр Compose үндсэн бүтэц:\n Dockerfile docker-compose.yml - апплкэйшн тус бүрийн бүтцийг тодорхойлох хэсэг. Файл дотор байгаа бүтцийн дагуу апплкэйшн серверүүдийг асааж тусгаарлагдсан орчин үүсгэнэ.  version: \u0026#39;2\u0026#39; services: postgresql: image: \u0026#39;docker.io/bitnami/postgresql:11-debian-10\u0026#39; environment: - ALLOW_EMPTY_PASSWORD=yes volumes: - \u0026#39;postgresql_data:/bitnami/postgresql\u0026#39; odoo: image: \u0026#39;docker.io/bitnami/odoo:14-debian-10\u0026#39; ports: - \u0026#39;80:8069\u0026#39; - \u0026#39;443:8071\u0026#39; volumes: - \u0026#39;odoo_data:/bitnami\u0026#39; depends_on: - postgresql volumes: postgresql_data: driver: local odoo_data: driver: local Bitnami дах Odoo V14-н сервер, апплкэйшнг тодорхойлж байгаа docker-compose.yml -г задалж үзвэл postgresql, odoo гэсэн хоёр контейнераас services бүрдэж байна.\n ALLOW_EMPTY_PASSWORD=yes - ѳгѳгдлийн санг нууц үггүйгээр хандалт хийдэг болгож байна (тест хийж байгаа үед тохиромжтой). Продакшн орчинд тохиромжгүй сонголт. ports - [host-port]:[container-port] Хостинг портыг 80, 443 контейнер дэх 8069, 8071 порттой холбож байна. CLI - рүү бичвэл:  $ docker run -p 80:8069 --name odoo  depends_on - Compose хийхдээ эхлээд postgresql тодорхойлсон байна. Үүний дараа Odoo-г тохируулж байна. Ингэснээр ялгаатай хоёр контейнерээс хамааралтай байх нѳхцлийг тодорхойлж ѳгнѳ. Ѳѳрѳѳр хэлбэл нетворкинг хийж байгаа үед дарааллыг тодорхойлж ѳгѳх ба Odoo асахаас ѳмнѳ нь заавал Postgresql ассан байх ёстойг compose-д сануулж байна гэж хэлж болох юм. volumes - compose хийгдэж байгаа YAML-г CLI -руу хѳрвүүлбэл:  $ docker volume create --driver local --name postgresql_data $ docker volume create --driver local --name odoo_data буюу [Докэр хост] дотор odoo_data, postgresql_data гэсэн нэртэй local volume үүсгэж ѳгнѳ. Докэр хост-г дэлгэрүүлбэл:\nДокэр ажиллах бүтэц нь Docker Engine тѳвтэй ба дараах гурван хэсгээс бүрдэнэ.\n Docker daemon - Docker API хүсэлтүүд хүлээн авч image, container, network, volume - зэргийн зохион байгуулалт хийх, бусад Docker Service-үүдтэй deamon -ѳѳр дамжин холбогдох гэх мэт. Docker CLI (Command Line Interface) REST API - Клиенттай холбогдох, Docker deamon-той уялдан харилцана.  Ѳѳрѳѳр хэлбэл докэр дотор ажиллаж байгааг image-с тусад нь volume үүсгэн ѳгч байна. Ингэснээр тухайн контейнер унтарсан ч дата персист тѳлѳвтэй дахин ашиглаж болно гэсэн юм. \u0026ndash;driver гэдэг нь Докэр plugin ашиглаад зѳвхѳн Докэр роот-с хандалт хийх эрх локал volume үүсгэж байна. Датаг холбох ѳѳр нэг арга нь docker-compose дотор хостинг directory-г оноох боломжтой. Гэхдээ non-root хэрэглэгчийн хувьд харгалзах хандах эрх байгааг нягтлан шалгах хэрэгтэй. Жишээ нь хост direcory-г тодорхойж буй:\nvolumes: - \u0026#39;odoo_data:/bitnami\u0026#39; #Docker Host-с дотор тодорхойлсон volume. - \u0026#39;./extra-addons:/bitnami/odoo/addons\u0026#39; # Хост directory-г Container руу оруулж байна. odoo_data:/bitnami дотор Odoo-г ажиллаж байх үеийн filestore -д Docker Host дотор odoo_data volume-д үүснэ. Docker volume руу зѳвхѳн Docker hosting хийж байгаа root хэрэглэгч хандах боломжтойг анхаарна уу.\n./extra-addons:/bitnami/odoo/addons - ./extra-addons, directory -г Odoo контейнер дах /bitnami/odoo/addons руу оруулж байна. Ингэснээр гуравдагч эдгээдийн модиуль болон хѳгжүүлэлтийн орчин дах нэмэлт модиулыг суулган ажиллуулах боломжтой болно.\n/bitnami/odoo/addons-г conf файл дотор тодорхойлж ѳгсѳн эсэхийг шалгах:\n$ docker exec -it \u0026lt;container-name\u0026gt; cat /opt/bitnami/odoo/odoo-server.conf Bitnami -г дах Dockerfile болон нэмэлт pkg суух үед Odoo-гийн коор модиулидын directory болон нэмэлтээр суулгах модиулын directory-г тодорхойлон .conf файлд тохируулсан байгааг харж болно.\n[options] addons_path = /opt/bitnami/odoo/odoo/addons,/opt/bitnami/odoo/addons ... docker-compose.yml - файл сүүлийн байдлаар:\nversion: \u0026#39;2\u0026#39; services: postgresql: image: \u0026#39;docker.io/bitnami/postgresql:11-debian-10\u0026#39; environment: - ALLOW_EMPTY_PASSWORD=yes volumes: - \u0026#39;postgresql_data:/bitnami/postgresql\u0026#39; odoo: image: \u0026#39;docker.io/bitnami/odoo:14-debian-10\u0026#39; ports: - \u0026#39;80:8069\u0026#39; - \u0026#39;443:8071\u0026#39; volumes: - \u0026#39;odoo_data:/bitnami\u0026#39; - \u0026#39;./extra-addons:/bitnami/odoo/addons\u0026#39; depends_on: - postgresql volumes: postgresql_data: driver: local odoo_data: driver: local Бүтэц:\n... # tree /bitnami-odoo/ |-- extra-addons |-- docker-compose.yml ... Docker-compose ажилууллах: $ docker-compose up -d Image-үүд татаж дуусан networking хийн done болсон бол:\nStatus: Downloaded newer image for bitnami/odoo:14-debian-10 Creating bitnami-odoo_postgresql_1 ... done Creating bitnami-odoo_odoo_1 ... done http://localhost/web/login хаягаар хандан bitnami -с тодорхойлсон нэвтрэх нэр: user@example.com нууц үг: bitnami, Odoo руу нэвтрэн орно. Эсхүл шинээр db тохируулах бол \u0026lsquo;http://localhost/web/database/selector - хаягаар орон тохируулж болно.\nDocker-compose унтраах: $ docker-compose down Volume шалгах: docker volume ls Volume устгах: docker volume rm \u0026lt;volume-name\u0026gt; ","permalink":"https://cadil.github.io/posts/2020-12-25-docker-compose/","summary":"Odoo -г Docker-с ажилууллах  Odoo -н тухай Bitnami-г ашиглан Bitnami-docker-odoo - ажилууллах docker-compose - коммандын талаар Docker Volume \u0026amp; persistent volume claim талаар Docker-compouse ажилууллах  Odoo-н тухайд Нээлттэй эх дээрх бизнес апплкэйшн ERP нь вэб дээр бүрэн ажиллах, ѳѳр системтэй интеграци хийх боломж, l10n зэргийг шийдсэн цогц апплкэйшн юм.\nBitnami-н тухайд Нээлттэй эх дээр суурьтай OSS софтвейрыг хялбар аргаар хүссэн орчин дээр суулган ажилуулна. Клоуд хостинг хийж байгаа бол Helm Chart -г ашиглан күбэрнетес, клустер-г хялбархан тохируулна.","title":"Odoo -г Docker-с ажилууллах"},{"content":"Localhost дээр Nginx ажилууллах Локалхост дээр Nignx вэбсервер асаах\ndocker run -d -p 80:80 --name webserver nginx Коммандын ажиллаж буй зарчим:\n docker - Докэр ачааллах үндсэн комманд. run - Контейнер ажлууллна. -d - Контейнерыг салангид тѳлѳвтэйгээр ажиллуулна. Процесс (веб-сервер) зогсвол контейнер мѳн зогсоно. -p 80:80 - Хостинг портыг 80 контейнер дэх 80 порттой [host-port]:[container-port] холбох үед ашиглана. [--name] - Контейнерт нэр онооно. nginx - Локал дээр ийм нэртэй repo байгаа эсэхийг шалгаад байхгүй бол Docker Hub - аас nginx image - татаж авна. Tag - ыг тодорхой бичиж ѳгѳѳгүй бол хамгийн сүүлийн хувилбар буюу nginx:latest - татаж авна.  Дээрх комманд ажиллаж дуусан бол browser-с http://localhost:80/ - хандан Nginx -д ажиллаж байгааг шалгаарай.\n","permalink":"https://cadil.github.io/posts/2020-12-21-nginx-container/","summary":"Localhost дээр Nginx ажилууллах Локалхост дээр Nignx вэбсервер асаах\ndocker run -d -p 80:80 --name webserver nginx Коммандын ажиллаж буй зарчим:\n docker - Докэр ачааллах үндсэн комманд. run - Контейнер ажлууллна. -d - Контейнерыг салангид тѳлѳвтэйгээр ажиллуулна. Процесс (веб-сервер) зогсвол контейнер мѳн зогсоно. -p 80:80 - Хостинг портыг 80 контейнер дэх 80 порттой [host-port]:[container-port] холбох үед ашиглана. [--name] - Контейнерт нэр онооно. nginx - Локал дээр ийм нэртэй repo байгаа эсэхийг шалгаад байхгүй бол Docker Hub - аас nginx image - татаж авна.","title":"Localhost дээр Nginx ажилууллах"},{"content":"Ubuntu контейнер ажилууллах docker run ubuntu Ubuntu контейнер руу shell -ээр хандах docker run -ti \u0026lt;your-container-name\u0026gt; /bin/bash Эсвэл:\ndocker exec -ti \u0026lt;your-container-name\u0026gt; bash  Note: shell-с гарахдаа Ctrl + D\n Ажиллаж байгаа контейнер инспект хийх (inspecting) Контейнер нэрийг тодорхойлох.\ndocker ps -a Контейнер нэрийг ашиглан инспект хийх.\ndocker inspect \u0026lt;your-container-name\u0026gt; IP хаяг тодорхойлох docker inspect \u0026lt;your-container-name\u0026gt; | grep IPAddress docker inspect --format {{.NetworkSettings.IPAddress}} \u0026lt;your-container-name\u0026gt; Лог шалгах docker logs \u0026lt;your-container-name\u0026gt; Контейнер зогсоох docker stop \u0026lt;your-container-name\u0026gt; Ажиллаагүй байгаа контейнер цэвэрлэх (clean up) docker rm -v $(docker ps -aq -f states=exited) ","permalink":"https://cadil.github.io/posts/2020-12-21-ubuntu-container/","summary":"Ubuntu контейнер ажилууллах docker run ubuntu Ubuntu контейнер руу shell -ээр хандах docker run -ti \u0026lt;your-container-name\u0026gt; /bin/bash Эсвэл:\ndocker exec -ti \u0026lt;your-container-name\u0026gt; bash  Note: shell-с гарахдаа Ctrl + D\n Ажиллаж байгаа контейнер инспект хийх (inspecting) Контейнер нэрийг тодорхойлох.\ndocker ps -a Контейнер нэрийг ашиглан инспект хийх.\ndocker inspect \u0026lt;your-container-name\u0026gt; IP хаяг тодорхойлох docker inspect \u0026lt;your-container-name\u0026gt; | grep IPAddress docker inspect --format {{.NetworkSettings.IPAddress}} \u0026lt;your-container-name\u0026gt; Лог шалгах docker logs \u0026lt;your-container-name\u0026gt; Контейнер зогсоох docker stop \u0026lt;your-container-name\u0026gt; Ажиллаагүй байгаа контейнер цэвэрлэх (clean up) docker rm -v $(docker ps -aq -f states=exited) ","title":"Ubuntu контейнер ажилууллах"},{"content":"Виртуалчлал Виртуал машин: Софтвейр контейнр дотор (үйлдлийн систем + апплкэйшнг) салангид бүтэцтэй ажиллуулна. Нэг физик серверт олон вирутал машин (ВМ) ажилуулах боломжтой. Гипервизор (Виртуал машин мониторинг ВММ) Виртуал машин бүрийн нѳѳцийг тооцоолж динамик хуваарилалт хийнэ.\nКонтейнр: Хѳнгѳн байх бүтэцтэй виртуалчлал (контейнэр) нэг хостинг дотор ажиллах боломж. Үйлдлийн системээс ялгаатай нь кернел байхгүй. Хостинг хийж байгаа машины кернелийг хуваалцаж ашиглана (Илүү хѳнгѳн бүцэтэй болгох гэж тэр). Контейнр хоорондын тусгаарлалт хийхдээ процесс тѳлѳвт тусгаарлалт ашиглана.\nДокэр контейнр Линукс контейнр (LXC) - с үүдэлтэй. LXC нь нэг хостинг дээр олон Линукс систем ажлууллах үйлдийн систем суурт виртуал аргачлал юм. Namespace, cgroup -ээр дамжих замаар LXC ажиллана. Докэр эхэн үедээ сингл-апплкэйшн LXC контейрн болгож LXC өөрчлөлт шинэчлэл хийгдэх болгонд илүү уян хатан, зѳѳвѳрлѳх боломжтой болсон.\nDocker нь кодыг нэмэлтүүдийн хамт image дотор байрлуулна. Нээлттэй эх дээрх багаж\n","permalink":"https://cadil.github.io/posts/2020-12-16-docker-container/","summary":"Виртуалчлал Виртуал машин: Софтвейр контейнр дотор (үйлдлийн систем + апплкэйшнг) салангид бүтэцтэй ажиллуулна. Нэг физик серверт олон вирутал машин (ВМ) ажилуулах боломжтой. Гипервизор (Виртуал машин мониторинг ВММ) Виртуал машин бүрийн нѳѳцийг тооцоолж динамик хуваарилалт хийнэ.\nКонтейнр: Хѳнгѳн байх бүтэцтэй виртуалчлал (контейнэр) нэг хостинг дотор ажиллах боломж. Үйлдлийн системээс ялгаатай нь кернел байхгүй. Хостинг хийж байгаа машины кернелийг хуваалцаж ашиглана (Илүү хѳнгѳн бүцэтэй болгох гэж тэр). Контейнр хоорондын тусгаарлалт хийхдээ процесс тѳлѳвт тусгаарлалт ашиглана.","title":"Докэр контейнр болон Виртуалчлал"},{"content":"Жишээ контейнер ажилуулах Докэр суулгах\n$ docker run hello-world Docker run командаар контейнер дуудаж ажиллуулна.\nhello-world нэртэй image-г локалаас хайж үзнэ. Хэрэв ийм нэртэй image олдохгүй бол Dockerhub-аас адил нэртэй image-г хайн ажиллуулна.\nHello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Контейнер ажиллаж байгаа эсэхийг шалгах docker ps  Note: Үр дүнд ажиллаж байгаа контейнер лист буцаахгүй буюу хоосон утга буцаавал контейнер ажиллаж дуусаад зогссон байна.\n Сүүлийн байдлаар ажиллаж байсан контейнер шалгах $ docker ps -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 562a70b66077 hello-world \u0026#34;/hello\u0026#34; 8 minutes ago Exited (0) 8 minutes ago zealous_feynman ","permalink":"https://cadil.github.io/posts/2020-12-17-hello-world-container/","summary":"Жишээ контейнер ажилуулах Докэр суулгах\n$ docker run hello-world Docker run командаар контейнер дуудаж ажиллуулна.\nhello-world нэртэй image-г локалаас хайж үзнэ. Хэрэв ийм нэртэй image олдохгүй бол Dockerhub-аас адил нэртэй image-г хайн ажиллуулна.\nHello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \u0026#34;hello-world\u0026#34; image from the Docker Hub.","title":"Жишээ контейнер ажилуулах (hello-world)"},{"content":"Танилцуулга Хамгийн хэрэгтэй гэсэн Development - gem - үүдээс эхнээс нь танилцаж явах болно. Мэдээж бид бүхэнд юуны ѳмнѳ rspec-rails gem хэрэгтэй. Rspec нь тест хийх зориулалттай framework ба олон талт боломжуудтай юм.\nDev Gems group :development, :test do gem \u0026#39;better_errors\u0026#39; gem \u0026#39;capybara-webkit\u0026#39; gem \u0026#39;factory_girl_rails\u0026#39; gem \u0026#39;ffaker\u0026#39; gem \u0026#39;database_cleaner\u0026#39; gem \u0026#39;letter_opener\u0026#39; gem \u0026#39;rspec-rails\u0026#39; gem \u0026#39;pry\u0026#39; gem \u0026#39;pry-nav\u0026#39; gem \u0026#39;pry-rails\u0026#39;, \u0026#39;~\u0026gt; 0.3.2\u0026#39; gem \u0026#39;simple_bdd\u0026#39; gem \u0026#39;shoulda-matchers\u0026#39; gem \u0026#39;spring\u0026#39; end Дээр байгаа нийт 13 Development, test - gem - үүдийг нэг нэгээр нь дэлгэрэнгүй үзэх болно. Энэ удаа бид gem \u0026lsquo;rspec-rails\u0026rsquo; дэлгэрэнгүй авч үзнэ. Rspec - ыг ажиллуулах үед capybara-webkit суулгахыг шаардана. Capybara-webkit-ыг суулгахын ѳмнѳ Qt libraries суулгасан байх шаардлагатай. Энд дарж суулгах заавартай танилцаарай.\nrspec-rails rspec-rails нь Rails 3.x 4.x зориулсан testing framework юм. Gemfile - ын group :development, :test do - дотор бичиж ѳгнѳ:\ngroup :development, :test do gem \u0026#39;rspec-rails\u0026#39; gem \u0026#39;capybara-webkit\u0026#39; end Дараагаар нь терминал дээр:\n{% codeblock %} $ bundle install {% endcodeblock %}\nBundle install хийгдэж дууссан бол, rspec - ээ суулгана. Терминал дээр:\n{% codeblock %} $ rails generate rspec:install {% endcodeblock %}\n/spec/rails_helper.rb замаар орон require ‘rspec/rails’ - ыг нэмнэ:\nrequire \u0026#39;rspec/rails\u0026#39; Home Spec /spec - фолдер дотор features - фолдер шинээр үүсгэнэ. Энэ фолдер дотор бид spec-үүдээ бичээд явах юм.\n{% codeblock %} $ cd spec $ mkdir features {% endcodeblock %}\nШинээр үүсгэсэн features - фолдер дотроо home_spec.rb - үүсгэж ѳгнѳ:\n{% codeblock %} $ vi /spec/features/home_spec.rb {% endcodeblock %}\nЭнэ хичээлийн явцад [Vim](https://en.wikipedia.org/wiki/Vim_(text_editor) ашиглах ба та ѳѳрийн дурын editor-ыг ашиглах боломжтой.\nrequire \u0026#39;rails_helper\u0026#39; feature \u0026#34;Home page уруу орох\u0026#34; do scenario \u0026#34;Хэрэглэгч, тавтай морилно уу гэсэн текст харах\u0026#34; do visit root_path expect(page).to have_text(\u0026#34;Тавтай морилно уу CaDiL\u0026#34;) end end Spec - ыг ажиллуулах Бүх spec - ыг ажлуулах:\n{% codeblock %} $ rspec {% endcodeblock %}\nФолдер дотор байгаа spec-үүдыг ажлуулах:\n{% codeblock %} $ rspec spec/features {% endcodeblock %}\nНэг spec ажлуулах:\n{% codeblock %} $ rspec spec/features/home_spec.rb {% endcodeblock %}\nSpec-ын дагуу rspec ажиллуулж үзэн гарсан алдааны мэдээллээр алдааг засаж үзье.\nHome controller - ыг index method - той хамт үүсгэх:\n{% codeblock %} $ rails g controller Home index {% endcodeblock %}\nHome index - ыг үндсэн хуудсаар сонгож ѳгѳхын тулд app/config/routes.rb - уруу орон:\nroot \u0026#39;home#index\u0026#39; бичиж ѳгнѳ.\nШинээр үүсгэсэн Home index үрүү орон доорх мѳрийг бичиж ѳгнѳ:\n\u0026lt;p\u0026gt;Тавтай морилно уу CaDiL\u0026lt;/p\u0026gt; ","permalink":"https://cadil.github.io/posts/2016-04-13-rspec-rails-gem/","summary":"Танилцуулга Хамгийн хэрэгтэй гэсэн Development - gem - үүдээс эхнээс нь танилцаж явах болно. Мэдээж бид бүхэнд юуны ѳмнѳ rspec-rails gem хэрэгтэй. Rspec нь тест хийх зориулалттай framework ба олон талт боломжуудтай юм.\nDev Gems group :development, :test do gem \u0026#39;better_errors\u0026#39; gem \u0026#39;capybara-webkit\u0026#39; gem \u0026#39;factory_girl_rails\u0026#39; gem \u0026#39;ffaker\u0026#39; gem \u0026#39;database_cleaner\u0026#39; gem \u0026#39;letter_opener\u0026#39; gem \u0026#39;rspec-rails\u0026#39; gem \u0026#39;pry\u0026#39; gem \u0026#39;pry-nav\u0026#39; gem \u0026#39;pry-rails\u0026#39;, \u0026#39;~\u0026gt; 0.3.2\u0026#39; gem \u0026#39;simple_bdd\u0026#39; gem \u0026#39;shoulda-matchers\u0026#39; gem \u0026#39;spring\u0026#39; end Дээр байгаа нийт 13 Development, test - gem - үүдийг нэг нэгээр нь дэлгэрэнгүй үзэх болно.","title":"Rspec-rails gem"},{"content":"Devise Gem Devise нь Rails дээр суурилсан уян хатан authentication шийдлийн нэг юм.\n Rack дээр суурилсан Rails engine дээр суурилсан бүрэн MVC шийдэл юм Нэг цагт олон моделиуд зэрэг хандалт хийх боломжтой  Инфо Devise ѳргѳн ашиглагддаг gem болохоор internet-ээс хайхад хүссэн мэдээллээ авах боломжтой. Доорх линкээр орон мэдээлэл авах боломжтой: Devise\nЭхлэл Devise 4.0 нь Rails 4.2 болон 4.2 дээшээ загваруудыг дэмжин ажиллана. Gemfile дотор хуулж ѳгѳх:\ngem 'devise' Хуулсан бол bundle install командыг ашиглан суулгана:\nbundle install Gemfile дотроо хуулан bundle install хийсэн бол generate хийн суулгах хэрэгтэй:\nrails generate devise:install Generate хийх явцад тохиргооны хэсэг гарч ирэх ба тэдгээрийг зааврын дагуу суулгах шаардлагатай. Тохиргоог хийж дууссан бол generate ашиглан Devise-д модель үүсгэж ѳгнѳ:\nrails generate devise MODEL MODEL - ын оронд апплкейшны хэрэглэгчийн классын нэрийг бичиж ѳгнѳ. Уг тохиолдолд User эсвэл Admin байж болно. Модель үүсгэсэн бол rake db:migrate хийж ѳгнѳ\nrake db:migrate Helper Devise нь controller болон views дотор helper үүсгэж ѳгсѳн байгаа. Controller хэсэгт user authentication оруулж ѳгѳх бол before_action (тухайн моделийг User гэж үзвэл)\nbefore_action :authenticate_user! Devise model - т User - ээс ѳѳр утга оноож ѳгсѳн бол “_user” оронд “_ѳѳрийн утга”аа онож ѳгѳх зарчмаар явна.\nХэрэглэгч бүртгүүлсэн болохыг шалгах helper:\nuser_signed_in? Одоогоор нэвтрэн орсон хэрэглэгч:\ncurrent_user Session рүү энэ хүрээллээр нэвтрэх боломжтой:\nuser_session ","permalink":"https://cadil.github.io/posts/2016-04-12-devise-gem/","summary":"Devise Gem Devise нь Rails дээр суурилсан уян хатан authentication шийдлийн нэг юм.\n Rack дээр суурилсан Rails engine дээр суурилсан бүрэн MVC шийдэл юм Нэг цагт олон моделиуд зэрэг хандалт хийх боломжтой  Инфо Devise ѳргѳн ашиглагддаг gem болохоор internet-ээс хайхад хүссэн мэдээллээ авах боломжтой. Доорх линкээр орон мэдээлэл авах боломжтой: Devise\nЭхлэл Devise 4.0 нь Rails 4.2 болон 4.2 дээшээ загваруудыг дэмжин ажиллана. Gemfile дотор хуулж ѳгѳх:\ngem 'devise' Хуулсан бол bundle install командыг ашиглан суулгана:","title":"Devise gem"},{"content":"MVC Rails нь MVC framework буюу тогтолцоо юм. Rails нь browser - ѳѳс ирэх хүсэлтүүдийг хүлээн авч controller-т ирсэн хүсэлтүүдийг декод (тайлж унших) хийх бѳгѳѳд уг болж байгаа процессыг action method гэж нэрлэдэг.\nRails - аас авах нэг сайн тал гэвэл дотоод холболтууд нь цэгцтэй, дэс дараалалтай ер нь хамгийн сайн бүтэцтэй. “Hello World” - энгийн апплкейшн бичихийн тулд Controller, View шинээр үүсгэж кодлоно. Мэдээж энэ хоёрыг холбож ѳгсѳн холбоос, зам (route) хэрэгтэй. Нэг зүйл дутаагаад байна уу даа, гэж бодож байж магадгүй. Model - ыг яагаад бичихгүй юм бэ гэж гайхаж байгаа байх, хариулт нь, бидний одоо бичиж энэхүү апплкейшн нь ямар нэг байдлаар Data ч юм уу ѳгѳгдлийн сантай холбогдохгүй болохоор Model-ыг шууд алгасая. Эхлээд Controller - оос эхэлцгээе. Шинээр апплейкшн үүсгэж байсан райлс командыг ашиглан одоогийн бяцхан тѳсѳл дотроо controller үүсгэх юм. rails generate - гэх энэ райлс командыг ашиглах ба цаашид бид rails g гэж товчилж бичиж явна шүү. Controller үүсгэж байгаа rails g - араас script бичиж ѳгѳх байгаа. За, “Say” гэсэн controller үүсгэцгээе.\ndemo\u0026gt; rails g controller Say hello goodbye create app/controllers/say_controller.rb route get \u0026quot;say/goodbye\u0026quot; route get \u0026quot;say/hello\u0026quot; invoke erb create app/views/say create app/views/say/hello.html.erb create app/views/say/goodbye.html.erb invoke test_unit create test/controllers/say_controller_test.rb invoke helper create app/helpers/say_helper.rb invoke test_unit create test/helpers/say_helper_test.rb invoke assets invoke coffee create app/assets/javascripts/say.js.coffee invoke scss create app/assets/stylesheets/say.css.scss  За terminal доошоогоо бас л баахан шинэ файл, directories үүсчихлээ дээ. Удахгүй эдгээр файлууд нь ямар учиртай болохыг зах зухаас нь онгичож үзэцгээнэ. Ямартай ч эхлээд чухлаас нь:\nclass SayController \u0026lt; ApplicationController def hello end def goodbye end end Хоосон, ил хул, код байхгүй юм шиг санагдаж байна уу? Нѳгѳѳ гоё удамшил ороод ирсэн байгаа юм л даа. Энгийнээр бол SayController гэсэн class нь ApplicationController - оос удамшчихлаа гэж. Нэг ёсондоо автомотоор бүхий л default утгуудыг нь ѳѳртѳѳ авчихлаа гэсэн үг л дээ. Тэхээр дээр байгаа код юу хийж болох, эсвэл яг одоогоор ямар үүрэг гүйцэтгэж байна гэж хэдүүлээ ѳѳрсѳддѳѳ асуулт тавиад үзэцгээе. Одоогоор бол дээрх код юу ч хийхгүй, ямар ч үүрэггүй байгаа л гэсэн үг. Маш энгийн, бидэнд hello() бас goodbye() гэсэн хоёр хоосон (empty) action method - ууд л байна. Яагаад бас hello(), goodbye() гэсэн method гараад ирэв ээ, гэж гайхаж байгаа байх. Энэ хэсгийг ойлгохын тулд ѳѳр нэг хэсэг үрүү ѳндийж харахгүй бол болохгүй нь дээ. Rails Handles requests буюу ирж байгаа хүсэлтүүдийг зохицуулагч.\nRails болон Request URLs Яг л бусад веб апплкейшнуудын адил, Rails application - ын URL хаягийг хэрэглэгчтэй холбож ѳгч байгаа холболт юм. Тухайн URL - руу хандах хүсэлт browser - ээс явуулахад ар талд нь мэдээж тухайн хүсэлтийг боловсруулан (апп кодууд), эргүүлэн хэрэглэгч рүү хүргэх юм. Туршаад үзье. http://localhost:3000/say/hello - энэ хаяг руу хандалт хийгээд үзэцгээе.\nAction Дараагийн алхам маань дэлгэцэнд юу харуулах вэ гэх асуулт. Энэ хэсгээс л View орж ирж байгаа юм даа. Controller - шинээр үүсгэж байхдаа бид бүхэн ямар script ашиглаж байсныг санаж байна уу? Санахгүй байгаа бол эргүүлэн нэг хараарай. Тэр командаар терминал доошоо олон файл, directory үүссэн байхаа. Тэр дунд template файл буюу controller-ын views - үүссэн байгаа.. Үүннээс үзэхэд бид Say нэртэй controller үүсгэсэн. Тэгэхээр views маань app/view/say - directory-д байгаа юм.\n\u0026lt;h1\u0026gt;Hello from Rails!\u0026lt;/h1\u0026gt; hello.html.erb - файлаа хадаглаад, browser - оо refresh хийгээд үзээрэй. Одоо ойлгосон байх, тийм үү.\nДүгнээд нэг харахад, бид Rails Application Tree - гээс хоёр файлын утга, арга, үүрэг зэргийг судлаад эзэмшчихлээ. Controller гэж юу болох талаар мэдэж авлаа, browser дээр template - modify хийж үзлээ. За тэгээд, Rails-ын шатлалыг харвал: controller нь app/controller дотор, views нь app/views гэсэн subdirectories дотор байрлаж байна.\nDynamic Апп гэж хэлэхэд хэцүү нэг энгийн static page ямартай ч хийчихлээ. Бага зэрэг Dynamic болговол ямарав, орох болгонд хэдэн цаг болж байгааг харуулдаг хэсэг нэмж ѳгцгѳѳе. Нэмэхийн тулд views-д байгаа template файлыг ѳѳрчлѳх хэрэгтэй. Цаг (Time) - харуулах string хэрэг болох юм. Үүнээс улбаалаад хоёр асуулт үүснэ. Нэгт, хэрхэн яаж Dynamic Content - оо одоо байгаа template - дээ нэмэх вэ? Хоёрт, цагаа хаанаа авах юм бэ?\nDynamic Content Райлс дотор Dynamic загвар оруулах олон арга бий. Хамгийн ѳргѳн ашигладдаг нь за одоо заагаад ѳгье. Ruby кодыг Template - тэйгээ embed (зарим энэ мэт үгийг орчуулахгүйгээр шууд хэрэглээд явна, угаасаа ч орчуулдахааргүй үг) хийх юм. Тиймээс л бид template файлаа show.html.erb гэж хадагалсан юм. Html.erb гэсэн формат залгаж бичсэн шалтгаан нь ERB гэсэн системыг Rails ѳрѳгжүүлэн дэмжээд явна. ERB нь Ruby - ын нэгэн хэсэг болж суудаг ба суулгах энэ тэрээ зүйл дээр санаа зовоод байх хэрэггүй. Erb нь output - үүдыг хувирган юу ч хамаагүй болгож болдог. Энгийнээр бол \u0026lt;%= and %\u0026gt; - гэх код нь Рубю кодоор танигдах хэдий ч үр дүнд нь string болон хѳрвүүлэгдэж байгаад л онцлог юм. Тэхээр \u0026lt;% … %\u0026gt; уг кодын дотор л утга аа оруулаад ѳгѳхѳд л үр дүн нь хэвлэгдэх юм. Жишээ нь:\n\u0026lt;h1\u0026gt;Hello from Rails!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Одоо цаг \u0026lt;%= Time.now %\u0026gt; болж байна. \u0026lt;/p\u0026gt; Одоо browser - оо refresh хийгээд үз. Харагдаж байгаа цаг бол Ruby - ын standard format - аар харагдаж байгаа.\nЦаг нэмэх Ерѳнхийдѳѳ applcation - оо Dynamic болгох ганц хоёр алхамтай танилцлаа.. Дараагийн алхам бол одоо харагдаж байгаа цаг нь хаанаас дамжин харагдаж байгааг тогтоон address хийж ѳгѳх юм.\nRuby-гын Time.now() method нь embed хийж hello.html.erb загварт дуудан ѳгч ажиллаж байна. Хэрэглэгч, хандагч, уг page руу хандах бүр хэдэн цаг болж байгааг яг таг харуулж байна. Жижиг хэмжээний ѳѳрчлѳлт оруулж үзэцгээе. Одоо харагдаж байгаа view хэсгийг энэ чигт нь үлдээж controller хэсэгт цагийг байрлуулах шаардлагатай гэж үзээд Controller хэсэгт action method - ыг @time гэсэн хувьсагчид орлуулна. class SayController \u0026lt; ApplicationController def hello @time = Time.now end def goodbye end end .html.erb - загвар дотор, controller хэсэгт оруулж ѳгсѳн хувьсагчаа орлуулж бичнэ.\n\u0026lt;h1\u0026gt;Hello from Rails!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; It is now \u0026lt;%= @time %\u0026gt; \u0026lt;/p\u0026gt; Browser - ѳѳ refresh хийгээд харвал controller дээр нэмсэн хувьсагч маань views хэсэгт буюу энэ хоёрын хооронд утга дамжин амжилттайгаар дэлгэцэд хэвлэн харуулж байна. Яагаад заавал controller - оос харуулж байгаа зүйлийг views - дээр зарлан, хоёр гурван юм нэмж хийж, ажил удаад байгаа юм гэж гайхаж магадгүй. Уг Application - дотор бол ингэж хийсэн хийгээгүй нээх ѳѳрчлѳлт гарахгүй. Гэхдээ логикоор харвал ингэж хийх нь бидэнд ашигтай юм. Жишээ нь: Application - оо цаашид хѳгжүүлж олон орны хэрэглэгч хандалт хийх боломжтой болгоё гэж тѳсѳѳлье. Үүн дээр үндэслэхэд, тухайн орны цагын бүсээс хамааран дэлгэцэнд хэдэн цаг болж байгааг харуулах нь чухал. Ингэж харуулахад хангалттай хэмжээний код нэмж бичих хэрэг болно. Харин энэ их хэмжээний код нь views - д тийм тохиромжтой шийдэл болж чадахгүй л болох уу! Харин controller - т цагийг харуулахаар шийдэж ѳгснѳѳр уг application - ыг илүү уян хатан боглож ѳгч байгаа ба controller хэсгээс ѳѳрчлѳсѳн цагын бүс нь views хэсэгт мѳн time object - ыг update хийгээд байх шаардлага байхгүй гэсэн үг юм. Цагыг Data гэж үз, тэгвэл заавал view болон controller - тэй холбогдсон байх шаардлагтай. Цаашид Model гэж судлаад ирэхээр бид энэ тухай илүү ихийг сурах болно.\nДүгнээд нэг харвал  Хэрэглэгч уг application-нд хандалтыг local-оос http://localhost:3000/say/hello - URL хаягаар хандан орсон.. Rails - routes - ыг тааруулж ѳгсѳн. 2 хэсэгт хуваан авч үзвэл, say хэсэг нь controller хэсгийг авч, ингэснээр Rails нь шинээр Ruby-гын SayController хэсгийг дуурайлган буюу удамшуулан үүсгэх боломжтой болсон. (app/controllers/say_controller.rb - гэх дарааллаар олж болно) Дараагийн хэсэгт нь hello - ыг action - гэдгийг тодорхойлсон. Rails нь тухайн нэрийн дагуу controller - оос method - ыг дуудсан. Энэхүү action method нь time object - ыг үүсгэж, @time гэсэн хувьсагч болгосон. Rails нь загвар ашиглан үр дүнг дэлгэцэд хэвлэдэг болсон. App/view directory -\u0026gt; subdirectory нь controller-ын (say) - тэй адил нэрээр, тэрхүү subdirectory дотор hello.html.erb. Rails нь уг файлыг ERB templating system - руу боловсруулан, controller хэсэгт утгыг (value) заан Ruby - д оруулж (embed) ѳгсѳн. Үр дүнг browser дээрээс харахад, Rails хүсэлтүүдийг боловсруулан, ажиллаж байсан.  Pages - үүдыг холбох Нэг хуудастай Web Application гэж ч бас хаана байхав. Энэ удаа бид applicaiton - доо энгийн веб загвар хийж үзэцгээе.\n2 action - доо нэг controller ашиглана. Яагаад гэвэл бидэнд одоо шинээр controller - үүсгээд байх шаардлага гараагүй болохоор.\nGoodbye action - г controller - т define хийгээд ѳгчихсѳн болохоор одоо app/views/say дотор шинэ template үүсгэж ѳгѳх юм. Goodbye.html.erb гэж байгаа учир нь action нь default template загвар авах үедээ action - ын нэртэй холбогдож байдаг болохоор гэж ойлгож болно. \u0026lt;h1\u0026gt;Goodbye!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Энд байх сайхан байна. \u0026lt;/p\u0026gt; Browser - рүүгээ ороод энэ удаа URL хаягаа ѳѳрчлѳѳд хандалт хийнэ. http://localhost:3000/say/goodbye\nХарин одоо хоёр page - ээ хооронд нь холболт хийх хэрэгтэй. Hello page - ыг Goodbye page - тэй холбоно. Цаашид application хийхдээ хоорондын холболтыг button ашиглаж хийнэ, энэ удаа зүгээр hyperlink - ашиглаад хийчихье.\nhello.html.erb - иймэрхүү байдлаар:\n\u0026lt;p\u0026gt;\u2028Say \u0026lt;a href=\u0026quot;/say/goodbye\u0026quot;\u0026gt;Goodbye\u0026lt;/a\u0026gt;! \u0026lt;/p\u0026gt; Харин goodbye.html.erb:\n\u0026lt;p\u0026gt;\u2028Say \u0026lt;a href=\u0026quot;/say/hello\u0026quot;\u0026gt;Hello\u0026lt;/a\u0026gt;! \u0026lt;/p\u0026gt; Дээрx аргаар бичиж болно, асуудалгүй ажиллана. Нѳгѳѳ талаас жаахан эмзэг л болох юм даа. Уг Application - ынхаа web server - ыг ѳѳрчлѳѳд үзьѳ гэж бодоход URL - ууд шууд танихаа болино. Тийм болохоор, бид иймэрхүү эрсдэл хүлээх хэрэг байхгүй. Rails цаанаасаа маш олон helper, methods байдаг болохоор ур аргуудыг views, template - д ашиглаж болно. Жишээл нь: link_to() - энэ method нь action - нд hyperlink үүсгэж ѳгдѳг жишээтэй. Басаж болохгүй, энэ method - ын хийж чадах зүйл их шүү. hello.html.erb - дээ link_to() - ашиглаад үзье:\n\u0026lt;h1\u0026gt;Hello from Rails!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; It is now \u0026lt;%= @time %\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Time to say \u0026lt;%= link_to \u0026quot;Goodbye\u0026quot;, say_goodbye_path %\u0026gt;! \u0026lt;/p\u0026gt; Түр зогсоод энэ мѳрийг сайн харьцгаая:\n\u0026lt;%= link_to \u0026#34;Goodbye\u0026#34;, say_goodbye_path %\u0026gt; Link_to - оор дуудах үйлдэл хийгдэж байна. (Rails-д method-ыг templates, helpers- ыг бичихид илүү хялбар болгож ѳгсѳн) say_goodbye_path нь зам гээд ойлгоход болно доо.\nGoodbye.html.erb - мѳн адил аргаар:\n\u0026lt;h1\u0026gt;Goodbye!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; It was nice having you here. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Say \u0026lt;%= link_to \u0026quot;Hello\u0026quot;, say_hello_path %\u0026gt; again. \u0026lt;/p\u0026gt; За энэ хүрээд энгийн туршилтын application маань дуусаж байна. Дараагийн хичээлээр бид жинхэнэ application хийхэд суралцах болно. Юу хийсэн бэ?  Rails application хэрхэн шинээр үүсгэх, үүсгэсэн application - доо controller шинээр үүсгэж сурлаа. Хэрхэн Dynamic контентыг controller дээр үүсгэх, үүсгэсэн контентоо view - ыг ашиглан харуулахад суралцсан. Хэрхэн page хооронд холбох талаар үзлээ.  ","permalink":"https://cadil.github.io/posts/2016-01-04-hello/","summary":"MVC Rails нь MVC framework буюу тогтолцоо юм. Rails нь browser - ѳѳс ирэх хүсэлтүүдийг хүлээн авч controller-т ирсэн хүсэлтүүдийг декод (тайлж унших) хийх бѳгѳѳд уг болж байгаа процессыг action method гэж нэрлэдэг.\nRails - аас авах нэг сайн тал гэвэл дотоод холболтууд нь цэгцтэй, дэс дараалалтай ер нь хамгийн сайн бүтэцтэй. “Hello World” - энгийн апплкейшн бичихийн тулд Controller, View шинээр үүсгэж кодлоно. Мэдээж энэ хоёрыг холбож ѳгсѳн холбоос, зам (route) хэрэгтэй.","title":"Hello, Rails!"},{"content":"Райлс апплкейшнг ѳѳр database - тэй холбох Райлс апплкейшнг ѳѳр database - тэй холбох гэж байгаа бол DB2, MySQL, Oracle, Postgres, Firefird болон SQL Server гэх мэтээр сонголтууд бий. SQLite 3 - ыг Райлс апплкейшнтэй холбож ашиглахын ѳмнѳ database driver суулгаж Library нь Райлсын database engine-тэй холбож ѳгѳх хэрэгтэй.\n Ѳѳрийн хувийн Rails API Documentation үүсгэх\n  Local орчинд ѳѳрийн Rails API Documentation үүсгэх боломжтой юм. Маш энгийн, доорх командыг ѳѳрийн терминал дээр бичихэд л хангалттай.\n rails_apps\u0026gt; rails new dummy_app rails_apps\u0026gt; cd dumny_app dumny_app\u0026gt; rake doc:rails  Хамгийн сүүлд бичсэн мѳр бага зэрэг хугацаа авна. Уншиж дуусмагц, Rails API Documentation нь doc/api гэсэн directory tree үүснэ. Нэг зѳвѳлгѳѳ хэлэхэд уг directory-г ѳѳрийн desktop уруу хуулаад dumnуapp tree -г устгах нь зүйтэй.   Rails API Documentation - хандах бол browser дээрээс doc/apo/index.html хаягаар орох боломжтой.  Дэлгэрэнгүй мэдээллийг тухайн цахим хаягаар орон шалгана уу:\n DB 2: http://raa.ruby-lang.org/project/ruby-db2 эсвэл http://rubyforge.org/projects/rubyibm Firebird: http://rubyforge.org/projects/fireruby/ MySQL: http://www.tmtm.org/en/mysql/ruby/ Oracle: http://rubyforge.org/projects/ruby-oci8 Postgres: https://bitbucket.org/ged/ruby-pg/wiki/Home SQL Server: https://github.com/rails-sqlserver SQLLite: https://github.com/luislavena/sqlite3-ruby  MySQL MySQL server болон client суулгая:\nsudo apt-get install mysql-server mysql-client libmysqlclient-dev  Суулгах явцад root user - ын нууц үгийг шинээр үүсгэж ѳгнѳ. libmysqlclient-dev - ыг суулгаж ѳгснѳѳр mysql2 gem - ыг compile хийж Райлс аппд MySQL-ыг холбох тохиргоог хийж ѳгѳх юм.\nPostgreSQL Шинэ repository-г нэмж ѳгѳѳд Postgre 9.3 суулгана:\nsudo sh -c \u0026quot;echo 'deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main' \u0026gt; /etc/apt/sources.list.d/pgdg.list\u0026quot; wget --quiet -O - http://apt.postgresql.org/pub/repos/apt/ACCC4CF8.asc | sudo apt-key add - sudo apt-get update sudo apt-get install postgresql-common sudo apt-get install postgresql-9.3 libpq-dev  Postgre-г суулгах явцад user тохиргоог хийж ѳгѳхгүй. Тийм болохоор дээр зааврын дагуу хийж тохиргоогоо хийгээрэй. chris - оронд ѳѳрийн нэрийг бичин гэж бодох хэрэгтэй.\nsudo -u postgres createuser chris -s # User-т нууц үгтэй хиймээр байна уу? Доорк коммандыг дагаад хийнэ үү. sudo -u postgres psql postgres=# \\password chris  ","permalink":"https://cadil.github.io/posts/2016-01-04-ror-with-database/","summary":"Райлс апплкейшнг ѳѳр database - тэй холбох Райлс апплкейшнг ѳѳр database - тэй холбох гэж байгаа бол DB2, MySQL, Oracle, Postgres, Firefird болон SQL Server гэх мэтээр сонголтууд бий. SQLite 3 - ыг Райлс апплкейшнтэй холбож ашиглахын ѳмнѳ database driver суулгаж Library нь Райлсын database engine-тэй холбож ѳгѳх хэрэгтэй.\n Ѳѳрийн хувийн Rails API Documentation үүсгэх\n  Local орчинд ѳѳрийн Rails API Documentation үүсгэх боломжтой юм. Маш энгийн, доорх командыг ѳѳрийн терминал дээр бичихэд л хангалттай.","title":"Rails болон ѳгѳгдлийн сан"},{"content":"Апп үүсгэх Шинээр райлс апплейкшн create хийхийн ѳмнѳ бид эхлэл хэсгээсээ эхлээд зохион байгуулал, эмх цэгцтэй байх хэрэгтэй. Work гэсэн нэртэй ** шинэ directory ** үүсгэнэ. Энэ ** work ** гэсэн directory дотор тѳслүүдээ шинээр үүсгээд явбал эмх цэгцтэй, амар юм. Work - дотор demo гэсэн райлс аппклейкшн үүсгэцгээе.\nrubys\u0026gt; mkdir work rubys\u0026gt; cd work work\u0026gt; rails new demo create create README.rdoc create Rakefile create config.ru : :\t:\t: create vendor/assets/stylesheets create vendor/assets/stylesheets/.keep run bundle install Fetching gem metadata from https://rubygems.rog/....... : :\t:\t: Your bundle is complete! Use 'bundle show [gemname]' to see where a bundled gem is installed work\u0026gt;  Дээр бичигдсэн ** rails new demo** коммандаар бид **demo** нэртэй ** directory** үүсгэлээ. Терминал доошоогоо subdirectory болон олон шинэ файлуудыг автомотаар default - аар үүсгэж ѳгѳв.\nwork\u0026gt; cd demo demo\u0026gt; ls -p app/ config/ db/ Gemfile.lock log/ Rakefile test/ vendor/ bin/ config.ru Gemfile lib/ public/ README.rdoc tmp/  Гэх мэтээр directory - ууд үүсгэх ба энэхүү chapter - т бид эдгээрийг ашиглах шаардлага одооогоор гарахгүй ба зѳвхѳн app/ directory-д ѳѳрсдийн кодоо бичих нэмж оруулах юм.\nДоорх коммандаар дэлгэрэнгүй мэдээлэл авах боломжтой:\ndemo\u0026gt; rake about  Мѳн дээрх кодоор алдаа хайж болдог ба жишээ нь JavaScript runtime - олдохгүй байгаа бол алдааны мэдээлэл гаргаж боломжит линкүүдээс татаж авах хүсэлт ирүүлнэ.\nrake about - аар алдаа илэрээгүй бол цааш үргэлжүүлцгээе. Одоо юу хийх хэрэгтэй вэ гэхээр Stand-alone Web server - ыг асаахад л болно. Ингэж server асааж байж л бид шинээр үүсгэсэн райлс аппклейншаа ажиллуулах юм.\ndemo\u0026gt; rails server =\u0026gt; Booting WEBrick =\u0026gt; Rails 4.0.0 application starting in development on http://0.0.0.0:30000 =\u0026gt; Run 'rails server -h' for more startup options =\u0026gt; Ctrl+C to shutdown server [2013-04-18 20:22:16] INFO WEBrick 1.3.1 [2013-04-18 20:22:16] INFO ruby 2.0.0 (2013-02-24) [x86_64-linux] [2013-04-18 20:22:16] INFO WEBrick::HTTPServer#start: pid=25170 port=3000  Web Server нь ямар server суулгасан эсэхээс шалтгаалан ажиллах ба Ruby-гийн хувьд WEBrick server нь ruby-гийн цѳм нь болж ѳгсѳн нэг үгээр бол ruby-г илтгэж чадахаар нэгэн бүхэл хэсэг нь болсон сервер юм. Гэхдээ яах уу, ѳѳрийн дурын веб серверыг суулган Ruby on Rails тай хослуулан ажиллуулж болно. Доорк коммандыг ашиглан WEBrick-ыг хүчлэн (force) ажиллуулж болно.\ndemo\u0026gt; rails server webtrick  Сервер асаасан код боксын хамгийн сүүлийн мѳрийг харвал server нь port:3000 дээр ассан байна. 0.0.0.0 гэсэн холболтыг авч үзвэл WEBrick нь тухайн address-д connection - д бүхэл талын зѳвшѳѳрлыг олгож байна гэж ойлгож болно. Ойлгогдохоор хэлбэл дурын browser дээр http://localhost:3000 address - аар хандан сервер рүү холбогдох юм.\nСервер ээ асаагаад localhost-oos харж болж байна. Терминал дээр сервер дээр болж байгаа үйл явцыг tracking - хийх боломжтой юм.\nCtrl + C - командыг ашиглан WEBrick-ыг унтраана. Гэхдээ одоохондоо битгий унтраагаарай бид цааш үргэлжлүүлэн явах болхлоор…\nАпплкейшнаа үүсгээд сервер ээ асаачихлаа, харин ерѳѳсѳѳ код бичсэнгүй ээ, тийм ээ? Дараагийн хэсгээс код уруу орцгооё!\n","permalink":"https://cadil.github.io/posts/2016-01-04-shineer-applieikshn-uusghekh.%D0%BC%D0%B4/","summary":"Апп үүсгэх Шинээр райлс апплейкшн create хийхийн ѳмнѳ бид эхлэл хэсгээсээ эхлээд зохион байгуулал, эмх цэгцтэй байх хэрэгтэй. Work гэсэн нэртэй ** шинэ directory ** үүсгэнэ. Энэ ** work ** гэсэн directory дотор тѳслүүдээ шинээр үүсгээд явбал эмх цэгцтэй, амар юм. Work - дотор demo гэсэн райлс аппклейкшн үүсгэцгээе.\nrubys\u0026gt; mkdir work rubys\u0026gt; cd work work\u0026gt; rails new demo create create README.rdoc create Rakefile create config.ru : :\t:\t: create vendor/assets/stylesheets create vendor/assets/stylesheets/.","title":"Шинээр апплейкшн үүсгэх"},{"content":"Оршил Руби дээр ажиллаж байх үед терминалтай бол байнга ажиллана. Хэрвээ терминал дээр ажиллаж мэдэхгүй бол анхан шатны хэдэн коммандуудын үүргийг тайлбарлан бичсэн байгаа.\nSUDO Kомманд Дийлэнх комманд нь sudo - оор эхэлдэг. SUDO буюу superuserdo нь тухайн роот хэрэглэгчийн бүрэн эрхийг идэвхжүүлэх, тухайн роот хэрэглэгчийн фолдер, файлыг бүрэн эрхтэйгээр удирдах эрх олгож байгаа юм. Sudo коммандыг ашиглах үѳд гараас хэрэглэгчийн нууц үгийг оруулж ѳгѳх ёстой.\nФайл болон Зам (Directory) Долгионтой тэмдэгт (~) ээр home directory-г илэрхийлнэ. Xэрэглэгч буюу user, долгионтой тэмдэгт (~) харагдаж байвал /home/user directory-д байна гэсэн үг.\npwd Энэ коммандын тусламжтайгаар аль directory-д байгаагаа мэдэж болно. Нэг үгээр бол замыг хэвлэн дэлгэцэнд харуулна. Жишээлбэл: Desktop directory дотор pwd комманд бичсэн гэж үзэхэд “~/Desktop” гэснийг терминал дээр хэвлэн харуулах юм. ls Directory дотор байгаа файлуудын list буюу нэрс, агуулгыг харуулна. ls -ын араас ѳѳр коммандууд ашиглан, тухайн directory дотор байгаа файлуудын хэмжээ, тѳрѳл, үүссэн огноо гэх мэт дэлгэрэнгүй мэдээллийг харах боломж бий.\ncd Тухайн directory - чиглэлыг ѳѳрчлѳх, нэг directory-гоос нѳгѳѳ directory уруу орох ерѳнхий үүрэгтэй.  root directory уруу хандах үѳд “cd /” home directory уруу хандах үед “cd” эсвэл “cd ~” Нэг алхамаар урагшлах үѳд “cd ..” Ѳмнѳх directory уруу буцах үед “cd -”  cp Файлыг хуулах, copy хийх үүрэг гүйцэтгэнэ. Жишээлбэл: “cp file foo” нь file - хуулах үйлдэл хийн хуулж байгаа файлдаа “foo” нэртэй нэр ѳгч байна. Directory, copy хийх гэж байгаа бол “cp -r directory foo” (рекурс хуулах). Рекурс нь ямар учиртай вэ? Directory-г хуулах үѳд бүх файлуудыг нь хуулах үйлдийг давтах гэх мэтээр…\nmv Файлыг ѳѳр байршил уруу шилжүүлэх мѳн нэр ѳѳрчлѳх үүрэгтэй. Жишээлбэл: “mv file foo” нь file - ын нэрийг foo болгон ѳѳрчилж байна. “mv foo ~/Desktop” комманд нь foo нэртэй файлыг Desktop Directory уруу шилжүүлж байна. rm Энэхүү коммандыг ашиглан файл усгтаж болно. Жишээлбэл: “rm -f user/desktop/foo” нь user-ын Desktop directory-гоос force-оор foo файлыг устгаж байна.\nrmdir Хоосон directory-г устгах үед ашиглана. Харин дотроо файл болон контент агуулагдаж байгаа directory-г устгахын тулд “rm -r” коммандыг ашиглана.\nmkdir Шинээр directory үүсгэх үүрэгтэй. Жишээлбэл: “mkdir music” нь music нэртэй directory үүсгэж байна.\nman Ѳѳр бусад коммандуудын хэрэглэх аргачлал, зааврыг харуулна. Жишээлбэл: “man man” гэж бичихэд man коммандыг үүрэг, хэрхэн ашиглах гэх мэт document гарч ирнэ. sudo Зѳвхѳн Root user - д зѳвшѳѳрѳл олгох үүрэгтэй. Жишээлбэл: home directory-гын гаднаас файл хуулах шаардлага гарлаа гэж бодоё. “mv /mydoc.odt ~/Documents/mydoc.odt” гэж бичин гэж бодож байвал энэ нь буруу юм. Яагаад гэвэл home directory - гын гаднаас юм оруулах зѳвшѳѳрѳл бидэнд байхгүй байгаад юм. Харин “sudo mv /mydoc.odt ~/Documents/mydoc.odt” гэж бичиж ѳгснѳѳр бүгд хэвийн ажиллана. sudo коммандыг ашиглаж байгаа үѳд болгоомжтой байх нь чухал. Root user - ээр хандаж байгаа үѳд system - ээ ч гэмтээх магадал бий болохоор.\n","permalink":"https://cadil.github.io/posts/2016-01-04-command-line/","summary":"Оршил Руби дээр ажиллаж байх үед терминалтай бол байнга ажиллана. Хэрвээ терминал дээр ажиллаж мэдэхгүй бол анхан шатны хэдэн коммандуудын үүргийг тайлбарлан бичсэн байгаа.\nSUDO Kомманд Дийлэнх комманд нь sudo - оор эхэлдэг. SUDO буюу superuserdo нь тухайн роот хэрэглэгчийн бүрэн эрхийг идэвхжүүлэх, тухайн роот хэрэглэгчийн фолдер, файлыг бүрэн эрхтэйгээр удирдах эрх олгож байгаа юм. Sudo коммандыг ашиглах үѳд гараас хэрэглэгчийн нууц үгийг оруулж ѳгѳх ёстой.\nФайл болон Зам (Directory) Долгионтой тэмдэгт (~) ээр home directory-г илэрхийлнэ.","title":"Энгийн коммандууд"},{"content":"Version Control Version Control - д Github, BitBucket - гээд олон байгаа. Дийлэнх тохиолдолд Git-ыг ашиглана. Git дээр райлс дээр хѳгжүүлэлт хийж байгаа тѳслѳѳ commit хийх ба ѳѳрчлѳлт бүрийг оруулаад тест хийж баталгаатай болгож байгаад commit хийгээд явах юм. Git дээр үүсгэсэн repository-д олон цагийг commit хийх болохоор энэ хэсэг их чухал юм.\nБагаараа хамтран райлс тѳсѳл дээр ажиллаж байгаа тохиолдолд CI буюу Continuous Integration - ыг сайн шийдсэн байх хэрэгтэй болдог. Ажиллах процесс нь багын гишүүд бүр ѳѳрийн ѳѳрчлѳлтыг repository-д нэмэхээс ѳмнѳ райлс апплейкшнд шинээр хийсэн ѳѳрчлѳлт бүрд тест хийн шалгаад явах юм. Энгийнээр бол багаар ажиллаж байгаа үед алдаатай commit хийсэн тохиолдолд багын ажлыг тэр чигт нь холион бантанд нь хутгадаг, тэр асуудлыг шийдээд ѳгѳх, тѳслийн удирдагч ѳѳрѳѳ хувийн тохиргоо хийж ѳгсѳнѳѳр тѳслийг баллах гэсэн аюулаас нэг алхам холдож чадаж байгаа юм. Git Ѳѳрийн github аккоунттайгаа холбох хэрэгтэй. Аккоунт байхгүй бол Github - орж бүртгүүлээрэй.\nYOUR NAME, YOUR@EMAIL.COM оронд ѳѳрийн нэр, майл хаягаа бичнэ:\ngit config --global color.ui true git config --global user.name \u0026quot;YOUR NAME\u0026quot; git config --global user.email \u0026quot;YOUR@EMAIL.com\u0026quot; ssh-keygen -t rsa -C \u0026quot;YOUR@EMAIL.com\u0026quot;  SSH Шинээр үүссэн SSH key - ыг ѳѳрийн github account - д хуулж ѳгнѳ. Copy хийсэн бол SSH Key-ээ энд хуулна.\ncat ~/.ssh/id_rsa.pub  Холболт шалгах Хуулсан бол ажиллаж байгаа эсэхийг нь check хийж үзье:\nssh -T git@github.com  Ийм message гарч ирэх ёстой:\nHi excid3! You've successfully authenticated, but GitHub does not provide shell access.  ","permalink":"https://cadil.github.io/posts/2016-01-03-git/","summary":"Version Control Version Control - д Github, BitBucket - гээд олон байгаа. Дийлэнх тохиолдолд Git-ыг ашиглана. Git дээр райлс дээр хѳгжүүлэлт хийж байгаа тѳслѳѳ commit хийх ба ѳѳрчлѳлт бүрийг оруулаад тест хийж баталгаатай болгож байгаад commit хийгээд явах юм. Git дээр үүсгэсэн repository-д олон цагийг commit хийх болохоор энэ хэсэг их чухал юм.\nБагаараа хамтран райлс тѳсѳл дээр ажиллаж байгаа тохиолдолд CI буюу Continuous Integration - ыг сайн шийдсэн байх хэрэгтэй болдог.","title":"Git"},{"content":"Руби суулгах [2.2.3] sudo apt-get update sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev  Эхллэд зарим шаардлагатай зүйлсийг суулгана. Ruby-г суулгах үндсэндээ 3 арга байдаг. Тус бүр ѳѳр ѳѳрийн гэсэн давуу талуудтай.\n rbenv rvm from source  Хамгийн recommended арга нь rbenv, rvm хоёр юм. Энэ удаа rbenv аргаар ruby-г суулгана. Rbenv арга нь энгийн хоёр алхамтай. Эхлээд rbenv-гээ суулгаад дараа нь ruby-build - ээ суулгана:\ncd git clone git://github.com/sstephenson/rbenv.git .rbenv echo 'export PATH=\u0026quot;$HOME/.rbenv/bin:$PATH\u0026quot;' \u0026gt;\u0026gt; ~/.bashrc echo 'eval \u0026quot;$(rbenv init -)\u0026quot;' \u0026gt;\u0026gt; ~/.bashrc exec $SHELL git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build echo 'export PATH=\u0026quot;$HOME/.rbenv/plugins/ruby-build/bin:$PATH\u0026quot;' \u0026gt;\u0026gt; ~/.bashrc exec $SHELL git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash rbenv install 2.2.3 rbenv global 2.2.3 ruby -v  Rubygems - ыг илүү дутуу documentation-гүйгээр суулгана:\necho \u0026quot;gem: --no-ri --no-rdoc\u0026quot; \u0026gt; ~/.gemrc gem install bundler  Rails суулгах [4.2.4] Rails суулгахын ѳмнѳ NodeJS суулгана:\ncurl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash - sudo apt-get install -y nodejs  Rails суулгая:\ngem install rails -v 4.2.4  Rails суусан эсэхийг шалгах:\nrbenv rehash  Rails -v коммандыг ашиглан яг бүрэн суусан эсэхийг шалгая:\nrails -v # Rails 4.2.4  ","permalink":"https://cadil.github.io/posts/2016-01-03-ruby-on-rails-setup/","summary":"Руби суулгах [2.2.3] sudo apt-get update sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev  Эхллэд зарим шаардлагатай зүйлсийг суулгана. Ruby-г суулгах үндсэндээ 3 арга байдаг. Тус бүр ѳѳр ѳѳрийн гэсэн давуу талуудтай.\n rbenv rvm from source  Хамгийн recommended арга нь rbenv, rvm хоёр юм. Энэ удаа rbenv аргаар ruby-г суулгана. Rbenv арга нь энгийн хоёр алхамтай. Эхлээд rbenv-гээ суулгаад дараа нь ruby-build - ээ суулгана:","title":"Ruby on Rails суулгах"}]